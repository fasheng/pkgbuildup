#!/usr/bin/bash
#
#   Author: Xu FaSheng <fasheng.xu@gmail.com>
#   
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 3, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script uses quite a few external programs during its execution. You
# need to have at least the following installed to function:
#   coreutils, curl, find (findutils), gawk, gettext, grep, sed

### Basic Functions

msg() {
	local mesg=$1; shift
	printf "==> ${mesg}\n" "$@" >&2
}

msg2() {
	local mesg=$1; shift
	printf "  -> ${mesg}\n" "$@" >&2
}

warning() {
    if [ -z "${IGNORE_WARN}" ]; then
	    local mesg=$1; shift
	    printf "==> $(gettext "WARNING:") ${mesg}\n" "$@" >&2
    fi
}

warning2() {
    if [ -z "${IGNORE_WARN}" ]; then
	    local mesg=$1; shift
	    printf "  -> $(gettext "WARNING:") ${mesg}\n" "$@" >&2
    fi
}

error() {
	local mesg=$1; shift
	printf "==> $(gettext "ERROR:") ${mesg}\n" "$@" >&2
}

abort() {
    error "$@"
    error "$(gettext "Aborting...")"
    exit 1
}

abort_if_var_empty() {
    local arg=$1
    local argname=$2
    if [[ -z "${arg}" ]]; then
        abort "$(gettext "variable \$%s is empty")" "${argname}"
    fi
}

warn_if_var_empty() {
    local arg=$1
    local argname=$2
    if [[ -z "${arg}" ]]; then
        warning "$(gettext "variable \$%s is empty")" "${argname}"
    fi
}

show_help() {
    printf "Description:\n"
    printf "    ${appname} is a helper tool for AUR package maintainer to automatic update PKGBUILD files\n"
    printf "\n"
    printf "Usage:\n"
    printf "    ${appname} [-p] [-l listkey] [-h help] [-v version]\n"
    printf "\n"
    printf "Options:\n"
    printf "    -p <file>\n"
    printf "        Use an alternate update script (instead of '${UPDATE_SCRIPT}')\n"
    printf "    -l, --listkey <file>\n"
    printf "        List keys in a template file\n"
    printf "    -h, --help\n"
    printf "        Prints help message\n"
    printf "    -v, --version\n"
    printf "        Prints version information\n"
    exit 1
}

show_version() {
    printf "${appname} ${version}\n"
    exit 1
}

source_safe() {
	shopt -u extglob
	if ! source "$@"; then
		abort "$(gettext "Failed to source %s")" "$1"
	fi
	shopt -s extglob
}

# TODO
# # Get file parent directory path
# # For example: "/usr/bin/bash" -> "/usr/bin"
# get_filepath() {
# 	local path=$1
#     filepath=${path%/*}
# 	printf "%s\n" "${filepath}"
# }

# # Get file name from path
# # For example: "/usr/bin/bash" -> "bash"
# get_filename() {
# 	local path=$1
#     filename=${path##*/}
# 	printf "%s\n" "${filename}"
# }


# Extract the protocol from a source entry - return "local" for local sources
# copy from makepkg
get_protocol() {
	if [[ $1 = *://* ]]; then
		# strip leading filename
		local proto="${1##*::}"
		printf "%s\n" "${proto%%://*}"
	elif [[ $1 = *lp:* ]]; then
		local proto="${1##*::}"
		printf "%s\n" "${proto%%lp:*}"
	else
		printf "%s\n" local
	fi
}

# copy from makepkg
get_downloadclient() {
	local proto=$1

	# loop through DOWNLOAD_AGENTS variable looking for protocol
	local i
	for i in "${DLAGENTS[@]}"; do
		local handler="${i%%::*}"
		if [[ $proto = "$handler" ]]; then
			local agent="${i##*::}"
			break
		fi
	done

	# if we didn't find an agent, return an error
	if [[ -z $agent ]]; then
		abort "$(gettext "Unknown download protocol: %s")" "$proto"
	fi

	# ensure specified program is installed
	local program="${agent%% *}"
	if [[ ! -x $program ]]; then
		local baseprog="${program##*/}"
		abort "$(gettext "The download program %s is not installed.")" "$baseprog"
	fi

	printf "%s\n" "$agent"
}

# Download file
# Arguments:
#   $1, file url
#   $2 [optional], file name to save as, default value is the
#     base name of file url
# copy from makepkg with some changes
download_file() {
	local url=$1
    local filename=$2
    
    # check arguments
    if [ -z "${filename}" ]; then
        filename="$(basename ${url})"
    fi

	local proto=$(get_protocol "$url")

	# find the client we should use for this URL
	local dlcmd
	dlcmd=$(get_downloadclient "$proto") || exit $?

	# local filename=$(get_filename "$url")
	# local url=$(get_url "$url")

	if [[ $proto = "scp" ]]; then
		# scp downloads should not pass the protocol in the url
		url="${url##*://}"
	fi

	msg2 "$(gettext "Downloading %s...")" "$filename"

	# temporary download file, default to last component of the URL
	local dlfile="${url##*/}"

	# replace %o by the temporary dlfile if it exists
	if [[ $dlcmd = *%o* ]]; then
		dlcmd=${dlcmd//\%o/\"$filename.part\"}
		dlfile="$filename.part"
	fi
	# add the URL, either in place of %u or at the end
	if [[ $dlcmd = *%u* ]]; then
		dlcmd=${dlcmd//\%u/\"$url\"}
	else
		dlcmd="$dlcmd \"$url\""
	fi

	local ret=0
	eval "$dlcmd || ret=\$?"
	if (( ret )); then
		[[ ! -s $dlfile ]] && rm -f -- "$dlfile"
		abort "$(gettext "Failure while downloading %s")" "$filename"
	fi

	# rename the temporary download file to the final destination
	if [[ $dlfile != "$filename" ]]; then
		mv -f "$dlfile" "$filename"
	fi
}

# List keys in template file
# Arguments:
#   $1, the template file
listkey() {
    tplfile=$1
    if [ ! -e "${tplfile}" ]; then
        abort "$(gettext "file does not exist, %s")" "${tplfile}"
    fi

    awk '
BEGIN {
    keyreg="(^.*){% *(\\w+) *%}(.*$)"
}

keyreg {
    while ($0 ~ keyreg) {
        key=gensub(keyreg, "\\2", "")
        $0=gensub(keyreg, "\\1\\3", "")
        if (key in keys == 0) {
            keys[key]=l++
        }
    }
}

END {
    PROCINFO["sorted_in"] = "@val_num_asc"
    for (key in keys) {
        print key
    }
}
' ${tplfile}
}

# Join multi-line strings to one line
joinline() {
    echo $*
}

# Decode url string, such as convert "%2b" to "+"
urldecode() {
    local tmpstr="$(cat - | sed -e 's/%/\\x/g')"
    printf "${tmpstr}\n"
}

# Get latest file by parsing web page
# Arguments:
#   $1, url of the web page
#   $2, regexp of the file name, used by "grep -oP" to get the last file
get_latest_file_by_parsing_web_page() {
    local url=$1
    local filereg=$2
    
    abort_if_var_empty "${url}" "url"
    abort_if_var_empty "${filereg}" "filereg"
    
    # get web page content
    local get_page_cmd=$(printf "${GET_PAGE_CMD}" ${url})
    local web_content=$(eval "${get_page_cmd}")
    
    # decode url and get latest file
    local matched_files=$(echo "${web_content}" | urldecode | grep -o -P ${filereg})
    local latest_file=$(echo "${matched_files}" | sort -n | tail -1)
    if [[ -z "${latest_file}" ]]; then
        # get latest file failed
        return 1
    fi
    
    printf "%s\n" "${latest_file}"
}

# Generate PKGBUILD from template file
# Arguments:
#   $1, the template file, such as "PKGBUILD.template"
#   $2 [optional], the key-values for template file,
#     and echo key-value own one line, such as:
#       "key1=value1
#        key2=value2
#        key3=value3"
#   $3 [optional], the output PKGBUILD file, default is in the same
#     directory with template file
generate_pkgbuild() {
    msg2 "$(gettext "Starting generate_pkgbuild()...")"
    local tplfile=$1
    local keyvalues=$2
    local pkgfile=$3
    
    # check arguments
    abort_if_var_empty "${tplfile}" "tplfile"
    warn_if_var_empty "${keyvalues}" "keyvalues"
    if [[ -z "${pkgfile}" ]]; then
        pkgfile="$(dirname ${tplfile})/${PKGBUILD_SCRIPT}"
    fi
    
    # replace keys to values in template file to generate PKGBUILD
    # file, if key is undefined, just replace to empty
    msg2 "$(gettext "Key-values: %s")" "$(joinline ${keyvalues})"
    msg2 "$(gettext "Generate '%s' through template file '%s'")" "${pkgfile}" "${tplfile}"
    awk -v keyvalues_str="${keyvalues}" '
BEGIN {
    keyreg="(^.*){% *(\\w+) *%}(.*$)"

    # build keyvalues array
    split(keyvalues_str, lines, "\n")
    for (i in lines) {
        split(lines[i], arr, "=")
        keyvalues[arr[1]]=arr[2]
    }
}

keyreg {
    tmpstr=$0
    while (tmpstr ~ keyreg) {
        key=gensub(keyreg, "\\2", "", tmpstr)
        if (key in keyvalues) {
            value=keyvalues[key]
            $0=gensub(keyreg, "\\1" value "\\3", "g")
        }

        # no matter there are undefined keys, just
        # remove it in tmpstr to avoid infinity loop
        tmpstr=gensub(keyreg, "\\1\\3", "g", tmpstr)
    }
    print
}
' ${tplfile} > ${pkgfile}
    
    # Check if all the template variables were replaced
    local keys=$(listkey ${pkgfile})
    if [ -n "${keys}" ]; then
        warning "$(gettext "there are undefined keys in %s:")" "${pkgfile}"
        warning2 "$(joinline ${keys})"
    fi
}

### Help Functions for Target Package

# Arguments:
#   $1, template file
#   $2, url of the web page which package file place in
#   $3, file name regexp, used by "grep -oP"
#   $4, package version regexp, used by "grep -oP"
update_package_in_source_site() {
    msg "$(gettext "Starting update_package_in_source_site()...")"
    local tplfile=$1
    local url=$2
    local filereg=$3
    local pkgverreg=$4
    local keyvalues=""
    
    abort_if_var_empty "${tplfile}" "tplfile"
    abort_if_var_empty "${url}" "url"
    abort_if_var_empty "${filereg}" "filereg"
    abort_if_var_empty "${pkgverreg}" "pkgverreg"
    msg2 "$(gettext "Updating %s...")" "${tplfile}"
    
    # get latest package name
    msg2 "$(gettext "Parsing web page to get latest package name: %s")" "${url}"
    local latest_file=$(get_latest_file_by_parsing_web_page "${url}" "${filereg}") || \
        { warning "$(gettext "update %s failed, skip it")" "${tplfile}"; return; }
    abort_if_var_empty "${latest_file}" "latest_file"
    keyvalues=$(printf "%s\n" "filename=${latest_file}")
    
    # get package version
    local pkgver=$(echo "${latest_file}" | grep -o -P ${pkgverreg} | tail -1)
    keyvalues=$(printf "%s\n%s" "${keyvalues}" "pkgver=${pkgver}")
    
    # download latest package
    local fileurl="${url}/${latest_file}"
    local savefile="$(dirname ${tplfile})/${latest_file}"
    download_file ${fileurl} ${savefile}
    
    # generate integrity checks 
    local md5=$(md5sum ${savefile} | awk '{print $1}')
    keyvalues=$(printf "%s\n%s" "${keyvalues}" "md5=${md5}")
    
    # generate new PKGBUILD
    generate_pkgbuild "${tplfile}" "${keyvalues}"
}


### Main
appname="pkgbuild_update"
version="0.1"

# config bash
shopt -s extglob

# Default variables, can be overwrite
IGNORE_WARN=""

if [[ -z "${GET_PAGE_CMD}" ]]; then
    GET_PAGE_CMD='/usr/bin/curl -sfL --retry 3 --retry-delay 3 %s'
fi

# The download utilities that should use to acquire sources
# Format: 'protocol::agent'
if [[ -z "${DLAGENTS}" ]]; then
    DLAGENTS=('ftp::/usr/bin/curl -fC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'
              'http::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'https::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'rsync::/usr/bin/rsync --no-motd -z %u %o'
              'scp::/usr/bin/scp -C %u %o')
fi

if [[ -z "${UPDATE_SCRIPT}" ]]; then
    UPDATE_SCRIPT='PKGBUILD_UPDATE'
fi

if [[ -z "${PKGBUILD_SCRIPT}" ]]; then
    PKGBUILD_SCRIPT='PKGBUILD'
fi


# Arguments
arg_update_script="${PWD}/${UPDATE_SCRIPT}"
arg_listkey=""
arg_help=""
arg_version=""

while [ $# -gt 0 ]; do
    case $1 in
        -p)             arg_update_script="$2"; shift; break ;;
        -l|--listkey)   arg_listkey="$2"; shift; break ;;
        -h|--help)      arg_help=t; break ;;
        -v|--version)   arg_version=t; break ;;
        --)             shift; break ;;
        *)              abort "$(gettext "Unknown argument: %s")" "$@" ;;
    esac        
done

# show help message
if [ "${arg_help}" ]; then
    show_help
fi

# show version
if [ "${arg_version}" ]; then
    show_version
fi

# list keys in template file
if [ "${arg_listkey}" ]; then
    listkey ${arg_listkey}
    exit
fi

# Load update script
source_safe ${arg_update_script}
