#!/usr/bin/bash
#
#   Author: Xu FaSheng <fasheng.xu@gmail.com>
#   
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 3, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script uses quite a few external programs during its execution. You
# need to have at least the following installed to function:
#   coreutils, curl, find (findutils), gawk, grep, sed

### Functions

msg() {
    printf "==> $*\n" >&2
}

msg2() {
    printf "  -> $*\n" >&2
}

warning() {
    printf "==> WARNING: $*\n" >&2
}

error() {
    printf "==> ERROR: $*\n" >&2
    exit 1
}

show_help() {
    printf "Description:\n"
    printf "    ${appname} is a helper tool for AUR package maintainer to automatic update PKGBUILD files\n"
    printf "\n"
    printf "Usage:\n"
    printf "    ${appname} [-p] [-l listkey] [-h help] [-v version]\n"
    printf "\n"
    printf "Options:\n"
    printf "    -p <file>\n"
    printf "        Use an alternate update script (instead of '${UPDATE_SCRIPT}')\n"
    printf "    -l, --listkey <file>\n"
    printf "        List keys in a template file\n"
    printf "    -h, --help\n"
    printf "        Prints help message\n"
    printf "    -v, --version\n"
    printf "        Prints version information\n"
    exit 1
}

show_version() {
    printf "${appname} ${version}\n"
    exit 1
}

source_safe() {
	shopt -u extglob
	if ! source "$@"; then
		error "Failed to source $1"
		exit 1
	fi
	shopt -s extglob
}

# Get file parent directory path
# For example: "/usr/bin/bash" -> "/usr/bin"
get_filepath() {
	local path=$1
    filepath=${path%/*}
	printf "%s\n" "${filepath}"
}

# Get file name from path
# For example: "/usr/bin/bash" -> "bash"
get_filename() {
	local path=$1
    filename=${path##*/}
	printf "%s\n" "${filename}"
}


# Download file
# Arguments:
#   $1, file url
download_file() {
	local netfile=$1

	local filepath=$(get_filepath "$netfile")
	if [[ -n "$filepath" ]]; then
		msg2 "$(gettext "Found %s")" "${filepath##*/}"
		rm -f "$srcdir/${filepath##*/}"
		ln -s "$filepath" "$srcdir/"
		return
	fi

	local proto=$(get_protocol "$netfile")

	# find the client we should use for this URL
	local dlcmd
	dlcmd=$(get_downloadclient "$proto") || exit $?

	local filename=$(get_filename "$netfile")
	local url=$(get_url "$netfile")

	if [[ $proto = "scp" ]]; then
		# scp downloads should not pass the protocol in the url
		url="${url##*://}"
	fi

	msg2 "$(gettext "Downloading %s...")" "$filename"

	# temporary download file, default to last component of the URL
	local dlfile="${url##*/}"

	# replace %o by the temporary dlfile if it exists
	if [[ $dlcmd = *%o* ]]; then
		dlcmd=${dlcmd//\%o/\"$filename.part\"}
		dlfile="$filename.part"
	fi
	# add the URL, either in place of %u or at the end
	if [[ $dlcmd = *%u* ]]; then
		dlcmd=${dlcmd//\%u/\"$url\"}
	else
		dlcmd="$dlcmd \"$url\""
	fi

	local ret=0
	eval "$dlcmd || ret=\$?"
	if (( ret )); then
		[[ ! -s $dlfile ]] && rm -f -- "$dlfile"
		error "$(gettext "Failure while downloading %s")" "$filename"
		plain "$(gettext "Aborting...")"
		exit 1
	fi

	# rename the temporary download file to the final destination
	if [[ $dlfile != "$filename" ]]; then
		mv -f "$SRCDEST/$dlfile" "$SRCDEST/$filename"
	fi

	rm -f "$srcdir/$filename"
	ln -s "$SRCDEST/$filename" "$srcdir/"
}

# List keys in template file
# Arguments:
#   $1, the template file
listkey() {
    tplfile=$1
    if [ ! -e "${tplfile}" ]; then
        error "file does not exist, ${tplfile}"
    fi

    awk '
BEGIN {
    keyreg="(^.*){% *(\\w+) *%}(.*$)"
}

keyreg {
    while ($0 ~ keyreg) {
        key=gensub(keyreg, "\\2", "")
        $0=gensub(keyreg, "\\1\\3", "")
        if (key in keys == 0) {
            keys[key]=l++
        }
    }
}

END {
    PROCINFO["sorted_in"] = "@val_num_asc"
    for (key in keys) {
        print key
    }
}
' ${tplfile}
}

# Join multi-line strings to one line
joinline() {
    str="$*"
    echo ${str}
}

# Decode url string, such as convert "%2b" to "+"
urldecode() {
    local tmpstr="$(cat - | sed -e 's/%/\\x/g')"
    printf "${tmpstr}\n"
}

# Get latest file by parsing web page
# Arguments:
#   $1, url of the web page
#   $2, regexp of the file name, used to get the last file
get_latest_file_by_parsing_web_page() {
    local url=$1
    local filereg=$2
    
    # check variables
    if [[ -z "${url}" ]]; then
        error "need argument for variable \$url"
    fi
    if [[ -z "${filereg}" ]]; then
        error "need argument for variable \$filereg"
    fi
    
    # get web page content
    local get_page_cmd=$(printf "${GET_PAGE_CMD}" ${url})
    local web_content=$(${get_page_cmd})
    
    # decode url and get latest file
    local matched_files=$(echo "${web_content}" | urldecode | grep -o -P ${filereg})
    local latest_file=$(echo "${matched_files}" | sort -n | tail -1)
    if [[ -z "${latest_file}" ]]; then
        # get latest file failed
        return 1
    fi
    
    printf "%s\n" "${latest_file}"
}

# Generate PKGBUILD from template file
# Arguments:
#   $1, the template file, such as "PKGBUILD.template"
#   $2 [optional], the key-values for template file,
#     multi key-values should be seprate by newline,
#     such as "key1=value1
#              key2=value2
#              key3=value3"
#   $3 [optional], the output PKGBUILD file, default is in the same
#     directory with template file
generate_pkgbuild() {
    msg "Starting generate_pkgbuild()..."
    local tplfile=$1
    local keyvalues=$2
    local pkgfile=$3
    
    # check variables
    if [[ -z "${tplfile}" ]]; then
        error "need argument for variable \$tplfile"
    fi
    if [[ -z "${keyvalues}" ]]; then
        warning "\$keyvalues is empty"
    fi
    if [[ -z "${pkgfile}" ]]; then
        pkgfile="$(dirname ${tplfile})/${PKGBUILD_SCRIPT}"
    fi
    
    # replace keys to values in template file to generate PKGBUILD
    # file, if key is undefined, just replace to empty
    msg2 "Generate '${pkgfile}' through template file '${tplfile}'..."
    awk -v keyvalues_str="${keyvalues}" '
BEGIN {
    keyreg="(^.*){% *(\\w+) *%}(.*$)"

    # build keyvalues array
    split(keyvalues_str, lines, "\n")
    for (i in lines) {
        split(lines[i], arr, "=")
        keyvalues[arr[1]]=arr[2]
    }
}

keyreg {
    tmpstr=$0
    while (tmpstr ~ keyreg) {
        key=gensub(keyreg, "\\2", "", tmpstr)
        
        if (key in keyvalues) {
            value=keyvalues[key]
            tmpstr=gensub(keyreg, "\\1" value "\\3", "g", tmpstr)
            $0=gensub(keyreg, "\\1" value "\\3", "g")
        } else {
            # if there are undefined keys, just remove it only in
            # tmpstr to avoid infinity loop
            value=""
            tmpstr=gensub(keyreg, "\\1" value "\\3", "g", tmpstr)
            print "# WARNING: there are undefined keys in next line"
        }
    }
    print
}
' ${tplfile} > ${pkgfile}
    
    # Check if all the template variables were replaced
    local keys=$(listkey ${pkgfile})
    if [ -n "${keys}" ]; then
        warning "there are undefined keys in ${pkgfile}:"
        msg2  "$(joinline ${keys})"
    fi
}

### Main
appname="pkgbuild_update"
version="0.1"

# config bash
shopt -s extglob

# Default variables, can be overwrite

if [[ -z "${GET_PAGE_CMD}" ]]; then
    GET_PAGE_CMD='/usr/bin/curl -sfL --retry 3 --retry-delay 3 %s'
fi

# The download utilities that should use to acquire sources
# Format: 'protocol::agent'
if [[ -z "${DLAGENTS}" ]]; then
    DLAGENTS=('ftp::/usr/bin/curl -fC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'
              'http::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'https::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'rsync::/usr/bin/rsync --no-motd -z %u %o'
              'scp::/usr/bin/scp -C %u %o')
fi

if [[ -z "${UPDATE_SCRIPT}" ]]; then
    UPDATE_SCRIPT='PKGBUILD_UPDATE'
fi

if [[ -z "${PKGBUILD_SCRIPT}" ]]; then
    PKGBUILD_SCRIPT='PKGBUILD'
fi


# Arguments
arg_update_script="${PWD}/${UPDATE_SCRIPT}"
arg_listkey=""
arg_help=""
arg_version=""

while [ $# -gt 0 ]; do
    case $1 in
        -p)             arg_update_script="$2"; shift; break ;;
        -l|--listkey)   arg_listkey="$2"; shift; break ;;
        -h|--help)      arg_help=t; break ;;
        -v|--version)   arg_version=t; break ;;
        --)             shift; break ;;
        *)              error "Unknown argument: $@" ;;
    esac        
done

# show help message
if [ "${arg_help}" ]; then
    show_help
fi

# show version
if [ "${arg_version}" ]; then
    show_version
fi

# list keys in template file
if [ "${arg_listkey}" ]; then
    listkey ${arg_listkey}
    exit
fi

# Load update script
source_safe ${arg_update_script}
