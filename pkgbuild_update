#!/usr/bin/bash
#
#   Author: Xu FaSheng <fasheng.xu@gmail.com>
#   
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 3, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


### Functions

msg() {
    printf "==> $*\n"
}

msg2() {
    printf "  -> $*\n"
}

warning() {
    printf "==> WARNING: $*\n" >&2
}

error() {
    printf "==> ERROR: $*\n" >&2
    exit 1
}

show_help() {
    printf "Description:\n"
    printf "    ${appname} is a helper tool for AUR package maintainer to automatic update PKGBUILD files\n"
    printf "\n"
    printf "Usage:\n"
    printf "    ${appname} [-p] [-h help] [-v version]\n"
    printf "\n"
    printf "Options:\n"
    printf "    -p <file>\n"
    printf "        Use an alternate update script (instead of '${UPDATE_SCRIPT}')\n"
    printf "    -h, --help\n"
    printf "        Prints help message\n"
    printf "    -v, --version\n"
    printf "        Prints version information\n"
    exit 1
}

show_version() {
    printf "${appname} ${version}\n"
    exit 1
}

source_safe() {
	shopt -u extglob
	if ! source "$@"; then
		error "Failed to source $1"
		exit 1
	fi
	shopt -s extglob
}

# Get file parent directory path
# For example: "/usr/bin/bash" -> "/usr/bin"
get_filepath() {
	local path=$1
    filepath=${path%/*}
	printf "%s\n" "${filepath}"
}

# Get file name from path
# For example: "/usr/bin/bash" -> "bash"
get_filename() {
	local path=$1
    filename=${path##*/}
	printf "%s\n" "${filename}"
}


# Download file
# Arguments:
#   $1, file url
download_file() {
	local netfile=$1

	local filepath=$(get_filepath "$netfile")
	if [[ -n "$filepath" ]]; then
		msg2 "$(gettext "Found %s")" "${filepath##*/}"
		rm -f "$srcdir/${filepath##*/}"
		ln -s "$filepath" "$srcdir/"
		return
	fi

	local proto=$(get_protocol "$netfile")

	# find the client we should use for this URL
	local dlcmd
	dlcmd=$(get_downloadclient "$proto") || exit $?

	local filename=$(get_filename "$netfile")
	local url=$(get_url "$netfile")

	if [[ $proto = "scp" ]]; then
		# scp downloads should not pass the protocol in the url
		url="${url##*://}"
	fi

	msg2 "$(gettext "Downloading %s...")" "$filename"

	# temporary download file, default to last component of the URL
	local dlfile="${url##*/}"

	# replace %o by the temporary dlfile if it exists
	if [[ $dlcmd = *%o* ]]; then
		dlcmd=${dlcmd//\%o/\"$filename.part\"}
		dlfile="$filename.part"
	fi
	# add the URL, either in place of %u or at the end
	if [[ $dlcmd = *%u* ]]; then
		dlcmd=${dlcmd//\%u/\"$url\"}
	else
		dlcmd="$dlcmd \"$url\""
	fi

	local ret=0
	eval "$dlcmd || ret=\$?"
	if (( ret )); then
		[[ ! -s $dlfile ]] && rm -f -- "$dlfile"
		error "$(gettext "Failure while downloading %s")" "$filename"
		plain "$(gettext "Aborting...")"
		exit 1
	fi

	# rename the temporary download file to the final destination
	if [[ $dlfile != "$filename" ]]; then
		mv -f "$SRCDEST/$dlfile" "$SRCDEST/$filename"
	fi

	rm -f "$srcdir/$filename"
	ln -s "$SRCDEST/$filename" "$srcdir/"
}

urldecode() {
    local tmpstr="$(cat - | sed -e 's/%/\\x/g')"
    printf "${tmpstr}\n"
}

# Get latest file by parsing web page
# Needs variables:
#   - $url, the parent path of url
#   - $file_regexp, regexp of file name, used to get the last file
get_latest_file_by_parsing_web_page() {
    # check variables
    if [[ -z "${url}" ]]; then
        error "need variable ${url}"
    fi
    if [[ -z "${file_regexp}" ]]; then
        error "need variable ${file_regexp}"
    fi
    
    # get web page content
    local get_page_cmd=$(printf "${GET_PAGE_CMD}" ${url})
    local web_content=$(${get_page_cmd})
    
    # decode url and get latest file
    local matched_files=$(echo "${web_content}" | urldecode | grep -o -P ${file_regexp})
    local latest_file=$(echo "${matched_files}" | sort -n | tail -1)
    if [[ -z "${latest_file}" ]]; then
        # get latest file failed
        return 1
    fi
    
    printf "%s\n" "${latest_file}"
}

# Generate PKGBUILD from template file
# Needs variables:
#   - $template_file, the template file, such as "PKGBUILD.template"
#   - $template_values [optional], the key-values for template file,
#     multi key-values should be seprate by newline,
#     such as "key1=value1
#              key2=value2
#              key3=value3"
#   - $pkgbuild_file [optional], the output PKGBUILD file, default is in the same
#     directory with template file
generate_pkgbuild() {
    msg "Starging generate_pkgbuild()..."
    
    # check variables
    if [[ -z "${template_file}" ]]; then
        error "need variable $template_file"
    fi
    if [[ -z "${template_values}" ]]; then
        warning "\$template_values is empty"
    fi
    if [[ -z "${pkgbuild_file}" ]]; then
        pkgbuild_file="${template_file%/*}/${PKGBUILD_SCRIPT}"
    fi
    
    msg2 "Generate '${pkgbuild_file}' through template file '${template_file}'..."
}

### Main
appname="pkgbuild_update"
version="0.1"

# config bash
shopt -s extglob

# Default variables, can be overwrite

if [[ -z "${GET_PAGE_CMD}" ]]; then
    GET_PAGE_CMD='/usr/bin/curl -sfL --retry 3 --retry-delay 3 %s'
fi

# The download utilities that should use to acquire sources
# Format: 'protocol::agent'
if [[ -z "${DLAGENTS}" ]]; then
    DLAGENTS=('ftp::/usr/bin/curl -fC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'
              'http::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'https::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
              'rsync::/usr/bin/rsync --no-motd -z %u %o'
              'scp::/usr/bin/scp -C %u %o')
fi

if [[ -z "${UPDATE_SCRIPT}" ]]; then
    UPDATE_SCRIPT='PKGBUILD_UPDATE'
fi

if [[ -z "${PKGBUILD_SCRIPT}" ]]; then
    PKGBUILD_SCRIPT='PKGBUILD'
fi

# Arguments
arg_update_script="${PWD}/${UPDATE_SCRIPT}"
arg_help=""
arg_version=""

while [ $# -gt 0 ]; do
    case $1 in
        -p)             arg_update_script="$2"; shift ;;
        -h|--help)      arg_help=t; break ;;
        -v|--version)   arg_version=t; break ;;
        --)             shift; break ;;
        *)              break ;;
    esac        
done

# show help message
if [ "${arg_help}" ]; then
    show_help
fi

# show version
if [ "${arg_version}" ]; then
    show_version
fi

# Load update script
source_safe ${arg_update_script}
